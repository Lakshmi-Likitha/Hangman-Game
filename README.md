# Hangman-Game
Hangman is a word-guessing game that involves two players: one player thinks of a secret word, and the other player tries to guess the word by suggesting individual letters within a certain number of attempts. 

Description
This repository contains a Python implementation of the classic Hangman game. The game employs a simple user interface for guessing letters and tries to guess a secret word intelligently using a predefined word list. The AI's guessing strategy is based on analyzing word patterns and frequency analysis of letters.

Features
  User-friendly text-based interface for playing the Hangman game.
  AI-driven secret word selection and letter guessing.
  The AI employs frequency analysis and pattern matching for intelligent guessing.
  The game ends when the word is guessed correctly or when the hangman figure is completed.

How to Play
  Clone the repository: 
  git clone https://github.com/Lakshmi-Likitha/hangman-game.git
  cd hangman-game
  
Run the Hangman game:
  python hangman.py
  
  The program will display an underscore for each letter in the secret word and prompt you to guess a letter.
  
  Enter a single letter and press Enter. The program will inform you if the guessed letter is correct or incorrect.
  
  The game continues until you guess the entire word correctly or the hangman figure is completed.
  
  You win if you guess the word before the hangman figure is drawn completely. Otherwise, you lose.

AI Strategy
  The AI intelligently guesses letters based on word patterns and the frequency of letters in common English words. It aims to maximize its chances of guessing       the word correctly by considering potential patterns and n-grams (groups of consecutive letters) in the secret word.

APPROACH: N-grams
  I have implemented n-grams approach for the given Hangman Challenge which extracts a sequence of n consecutive items (usually words or characters) from a given     text. N-grams are used to capture the local relationships between adjacent elements in a sequence. 
  Here I have used 2,3,4 and 5 grams to predict the word.
  I have created 4 methods named
build_ngram_dicts() 
  •	build_ngram_dicts creates dictionaries for different n-gram lengths (2, 3, 4, 5). It loops through each word in the self.full_dictionary and checks if the word   is valid using the is_valid_word method.
  
  •	For each valid word, it loops through the characters and builds n-grams of lengths 2 to 5. It increments the count of each n-gram in the respective dictionary    as ngram_2, ngram_3.
  
  •	At the end, it returns dictionaries for each n-gram length containing the n-gram frequencies.

is_valid_word()
  •	is_valid_word checks if a word is valid for the Hangman game. It counts the number of contiguous characters and checks if the count exceeds the given threshold   (default is 3). If it does, the word is considered invalid due to too many repeated characters.
  This threshold is used to determine if a character sequence like 'aaa' or 'lll' occurs excessively in a word. If it does, the word is considered invalid.

generate_patterns()
  •	This method generates patterns based on the provided clean_word and n (n can be 2, 3, 4, or 5). A pattern is a sequence of characters in clean_word where       
  underscores (_) indicate positions that need to be guessed. The method generates patterns for n-grams based on these underscores.
  
  •	If n is 2:
  It generates pairs of characters within the word using a sliding window approach.
  For example, if word is "c_a_r", it generates "a", "a", but not "__" (no pattern).
  These patterns are useful when there is an underscore between two known letters.
  
  •	If n is 3, 4, or 5:
  It generates longer patterns of 3, 4, or 5 characters respectively, again using a sliding window.
  It checks if these patterns have exactly one underscore (_) in them using the count method.
  For example, if word is "c__r_", it generates "ab" (c_a_r), "b_c_", "c__r", but not "a" (two underscores).
  These patterns are useful when one known letter is followed by an unknown letter.
  
  •	If n is anything other than 2, 3, 4, or 5:
  It returns an empty list, as these values of n are not supported.
  
  The generate_patterns() method helps to identify positions in the word where a known letter is adjacent to an unknown letter (underscore), or where an unknown      letter separates two known letters. These patterns provide hints for making better guesses in the Hangman game.

guess()
  •	guess method initializes the necessary variables. clean_word is a version of the given word without underscores (to consider only the known letters). len_word    stores the length of clean_word. letter_counts will store the frequency-weighted counts of letters based on n-grams.
  
  •	Loop which iterates through the patterns generated by the generate_patterns method for n = 5. For each pattern, it iterates through the 5-grams stored in         self.ngram_5 (generated earlier) and checks if the pattern matches any of the 5-grams. If the pattern matches, it extracts the letter at the underscore's           position, and updates letter_counts with the weighted count based on the 5-gram's frequency.
  
  •	The subsequent blocks do the same for patterns of lengths 4, 3, and 2, but with different weights (count * 4, count * 3, and count respectively) to reflect       their importance in guessing the next letter.
  
  •	If no letter counts were found, the method returns the most common letter in the dictionary that hasn't been guessed yet. If that's not possible, it returns a    random letter from the alphabet.
  
  •	If there are letter counts, the method filters out letters that have already been guessed and returns the letter with the highest weighted count, using the max   function with a custom key function. If no eligible letter is found, it returns an underscore (_), indicating no valid letter guess.
  
  •	Overall, the guess method uses n-gram patterns and their frequencies to make educated guesses for the next letter in the Hangman game, considering both known   
  and unknown letters in the word.

Contributions
  Contributions to this project are welcome! If you'd like to suggest improvements, add new features, or fix issues, please submit a pull request. You can also       open new issues for discussions or bug reports.
